name: Tasklists ‚Üí Issues
on:
  push:
    paths: ["TASKS.md", "docs/**.md", "**/*.md"]
permissions:
  contents: write
  issues: write
jobs:
  scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5
      - uses: actions/github-script@v8
        with:
          script: |
            const fs = require('fs');
            const path = 'TASKS.md';
            if (!fs.existsSync(path)) { return; }

            console.log('üìã Scanning TASKS.md for unchecked items...');

            let text = fs.readFileSync(path, 'utf8');
            const lines = text.split('\n');

            // Parse task items with context
            const tasks = [];
            let currentSection = '';
            let currentSubsection = '';
            let currentContext = [];

            for (let i = 0; i < lines.length; i++) {
              const line = lines[i];
              
              // Track section headers for context
              if (line.match(/^## /)) {
                currentSection = line.replace(/^## /, '').trim();
                currentSubsection = '';
                currentContext = [];
              } else if (line.match(/^### /)) {
                currentSubsection = line.replace(/^### /, '').trim();
                currentContext = [];
              }
              
              // Find unchecked items
              const match = line.match(/^-\s\[\s\]\s+(.*)$/);
              if (match) {
                const title = match[1].trim();
                
                // Skip if already tracked
                if (/#\d+/.test(title)) continue;
                
                // Extract metadata from title and context
                const metadata = {
                  title: title,
                  section: currentSection,
                  subsection: currentSubsection,
                  adrRefs: [],
                  issueRefs: [],
                  labels: ['task', 'from:tasklist'],
                  lineNumber: i,
                  contextLines: []
                };
                
                // Look for ADR references in title and surrounding context
                const adrPattern = /ADR-(\d{3})/g;
                let adrMatch;
                while ((adrMatch = adrPattern.exec(title)) !== null) {
                  metadata.adrRefs.push(`ADR-${adrMatch[1]}`);
                }
                
                // Look for issue references
                const issuePattern = /#(\d+)/g;
                let issueMatch;
                while ((issueMatch = issuePattern.exec(title)) !== null) {
                  metadata.issueRefs.push(parseInt(issueMatch[1]));
                }
                
                // Check preceding lines for context (up to 5 lines back)
                for (let j = Math.max(0, i - 5); j < i; j++) {
                  const contextLine = lines[j].trim();
                  if (contextLine && !contextLine.match(/^-\s\[/)) {
                    metadata.contextLines.push(contextLine);
                    
                    // Extract ADRs from context
                    let contextAdrMatch;
                    const contextAdrPattern = /ADR-(\d{3})/g;
                    while ((contextAdrMatch = contextAdrPattern.exec(contextLine)) !== null) {
                      const adrRef = `ADR-${contextAdrMatch[1]}`;
                      if (!metadata.adrRefs.includes(adrRef)) {
                        metadata.adrRefs.push(adrRef);
                      }
                    }
                  }
                }
                
                // Add component labels based on section
                if (currentSection.includes('Template')) {
                  metadata.labels.push('component:templates');
                } else if (currentSection.includes('Notebook')) {
                  metadata.labels.push('component:notebooks');
                } else if (currentSubsection.includes('Documentation') || currentSection.includes('Documentation')) {
                  metadata.labels.push('component:documentation');
                } else if (currentSection.includes('CLI') || currentSection.includes('Wizard')) {
                  metadata.labels.push('component:cli');
                } else if (currentSubsection.includes('Security') || currentSection.includes('Security')) {
                  metadata.labels.push('security');
                } else if (currentSection.includes('Testing')) {
                  metadata.labels.push('component:testing');
                } else if (currentSubsection.includes('Performance') || currentSection.includes('Performance')) {
                  metadata.labels.push('performance');
                }
                
                // Add priority based on section or keywords
                if (currentSection.includes('High Priority') || title.includes('CRITICAL') || title.includes('urgent')) {
                  metadata.labels.push('priority:high');
                } else if (currentSection.includes('Medium Priority')) {
                  metadata.labels.push('priority:medium');
                } else if (currentSection.includes('Lower Priority') || currentSection.includes('Future')) {
                  metadata.labels.push('priority:low');
                }
                
                tasks.push(metadata);
              }
            }

            console.log(`Found ${tasks.length} unchecked items`);

            // Rate limiting: Process in batches to avoid API rate limits
            const MAX_ISSUES_PER_RUN = 10;
            const DELAY_BETWEEN_CALLS = 2000; // 2 seconds

            if (tasks.length > MAX_ISSUES_PER_RUN) {
              console.log(`‚ö†Ô∏è  Limiting to ${MAX_ISSUES_PER_RUN} issues per run to avoid rate limits`);
              console.log(`   Remaining ${tasks.length - MAX_ISSUES_PER_RUN} items will be processed in next run`);
              tasks.length = MAX_ISSUES_PER_RUN;
            }

            // Helper function for delay
            const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

            // Create issues with rich metadata
            let issuesCreated = 0;
            for (const task of tasks) {
              // Rate limiting: Add delay between API calls
              if (issuesCreated > 0) {
                await delay(DELAY_BETWEEN_CALLS);
              }
              
              // De-dupe by existing issue title
              const { data: existing } = await github.rest.search.issuesAndPullRequests({
                q: `repo:${context.repo.owner}/${context.repo.repo} is:issue in:title "${task.title.replace(/"/g,'\\"')}"`
              });
              
              let number = existing.items.find(i => i.title === task.title)?.number;
              
              if (!number) {
                try {
                  // Build issue body with context
                  let body = `## Description\n\n${task.title}\n\n`;
                  
                  if (task.section) {
                    body += `## Context\n\n**Section:** ${task.section}`;
                    if (task.subsection) {
                      body += ` > ${task.subsection}`;
                    }
                    body += '\n\n';
                  }
                  
                  if (task.contextLines.length > 0) {
                    body += `**Additional Context:**\n\n`;
                    task.contextLines.slice(-3).forEach(line => {
                      body += `${line}\n`;
                    });
                    body += '\n';
                  }
                  
                  if (task.adrRefs.length > 0) {
                    body += `## Related ADRs\n\n`;
                    task.adrRefs.forEach(adr => {
                      body += `- ${adr}: [docs/adr/${adr}.md](../docs/adr/${adr}.md)\n`;
                    });
                    body += '\n';
                  }
                  
                  if (task.issueRefs.length > 0) {
                    body += `## Related Issues\n\n`;
                    task.issueRefs.forEach(issue => {
                      body += `- #${issue}\n`;
                    });
                    body += '\n';
                  }
                  
                  body += `## Source\n\n`;
                  body += `Created from TASKS.md (line ${task.lineNumber + 1})\n\n`;
                  body += `**Automatically tracked** - This issue was created automatically from TASKS.md.\n`;
                  body += `When this issue is closed, the corresponding item in TASKS.md will be marked as complete.\n`;
                  
                  // Create the issue with retry logic
                  let retries = 3;
                  let created = null;
                  while (retries > 0 && !created) {
                    try {
                      created = await github.rest.issues.create({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        title: task.title,
                        body: body,
                        labels: task.labels
                      });
                    } catch (error) {
                      retries--;
                      if (retries > 0 && (error.status === 403 || error.status === 429)) {
                        console.log(`  ‚ö†Ô∏è  Rate limited, waiting 60 seconds... (${retries} retries left)`);
                        await delay(60000);
                      } else {
                        throw error;
                      }
                    }
                  }
                  
                  number = created.data.number;
                  issuesCreated++;
                  console.log(`  ‚úì Created issue #${number}: ${task.title}`);
                  
                  // If there are ADR references, add them as comments
                  if (task.adrRefs.length > 0) {
                    await delay(DELAY_BETWEEN_CALLS);
                    const adrComment = `üìã **Related Architecture Decisions**\n\nThis task is related to the following ADRs:\n\n${task.adrRefs.map(adr => `- [${adr}](../docs/adr/${adr}.md)`).join('\n')}\n\nPlease review these decisions when working on this task.`;
                    
                    try {
                      await github.rest.issues.createComment({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        issue_number: number,
                        body: adrComment
                      });
                    } catch (error) {
                      console.log(`  ‚ö†Ô∏è  Failed to add ADR comment to #${number}: ${error.message}`);
                    }
                  }
                } catch (error) {
                  console.log(`  ‚ùå Failed to create issue for "${task.title}": ${error.message}`);
                  continue;
                }
              }
              
              // Replace the line with a tracked-issue checkbox
              const safeTitle = task.title.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
              const re = new RegExp(`^-\\s\\[\\s\\]\\s+${safeTitle}$`, 'm');
              text = text.replace(re, `- [ ] #${number} ${task.title}`);
            }

            // Write back the updated file
            fs.writeFileSync(path, text);

            console.log(`\n‚úÖ Created ${issuesCreated} new issues`);
            console.log(`‚úÖ Updated TASKS.md with issue references`);
      - name: Commit back
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git add -A && git diff --cached --quiet || git commit -m "chore: track checklist items as issues with metadata [skip ci]" && git push
